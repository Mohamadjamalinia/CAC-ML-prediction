# -*- coding: utf-8 -*-
"""CAC-ML-prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WAeAuvld6bF-qvxAabpOT9AQPOYwJbYV

## Libraries and Dependencies
"""

import pandas as pd
import numpy as np
import json
from sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold, GridSearchCV
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.metrics import roc_auc_score, confusion_matrix, classification_report, roc_curve, auc, f1_score, precision_score, recall_score
from sklearn.base import clone
from sklearn.utils import resample
from sklearn.svm import SVC
from sklearn.linear_model import SGDClassifier, LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.neural_network import MLPClassifier
import seaborn as sns
import matplotlib.pyplot as plt

"""## Data Preprocessing"""

# Load datasets separately for overall cohort, men, and women
data = pd.read_csv('machine learning CTA.csv')


# Define features and target variable
X = data.drop(columns=['CAC_0'])
y = data['CAC_0']

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size=0.3,
                                                    random_state=42,
                                                    stratify=y)

# Define categorical and numerical features
categorical_features = ['sex', 'dm', 'htn', 'hlp',
                        'liver_fat_content_MASLD', 'fmh_fld', 'fmh_CVD',
                        'fmh_dm', 'statin', 'asa',
                        'hypothyroid', 'cigarette_cat', 'alcohol_cat',
                        'physical_act'
]
numerical_features = ['age', 'ef', 'wc',
                      'hc', 'sbp', 'dbp',
                      'bmi', 'no_cmrf', 'sitting_time_hour',
                      'gfr', 'bun']

# Define preprocessing steps
numeric_transformer = Pipeline(steps=[
    ('scaler', StandardScaler())
])


preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numerical_features),
        ('cat', 'passthrough', categorical_features)
    ])

"""## Hyperparameter Optimization"""

# Define `calculate_metrics` before using it
def calculate_metrics(model, X_train, y_train, X_test, y_test):
    model.fit(X_train, y_train)
    y_train_pred = model.predict(X_train)
    y_test_pred = model.predict(X_test)

    train_auc = roc_auc_score(y_train, y_train_pred)
    test_auc = roc_auc_score(y_test, y_test_pred)

    train_f1 = classification_report(y_train, y_train_pred, output_dict=True)['1']['f1-score']
    test_f1 = classification_report(y_test, y_test_pred, output_dict=True)['1']['f1-score']

    tn, fp, fn, tp = confusion_matrix(y_train, y_train_pred).ravel()
    sensitivity_train = tp / (tp + fn)
    specificity_train = tn / (tn + fp)
    npv_train = tn / (tn + fn)
    ppv_train = tp / (tp + fp)

    tn, fp, fn, tp = confusion_matrix(y_test, y_test_pred).ravel()
    sensitivity_test = tp / (tp + fn)
    specificity_test = tn / (tn + fp)
    npv_test = tn / (tn + fn)
    ppv_test = tp / (tp + fp)

    return {
        'Train AUC': train_auc,
        'Test AUC': test_auc,
        'Train F1 Score': train_f1,
        'Test F1 Score': test_f1,
        'Train Sensitivity': sensitivity_train,
        'Test Sensitivity': sensitivity_test,
        'Train Specificity': specificity_train,
        'Test Specificity': specificity_test,
        'Train NPV': npv_train,
        'Test NPV': npv_test,
        'Train PPV': ppv_train,
        'Test PPV': ppv_test
    }

  # Define classifiers and their expanded parameter grids
model_params = {
    'Random Forest': {
        'model': RandomForestClassifier(random_state=42),
        'params': {
            'classifier__n_estimators': [100, 200, 500],
            'classifier__max_depth': [None, 10, 20, 30],
            'classifier__min_samples_split': [2, 5, 10]
        }
    },
    'SGD Classifier': {
        'model': SGDClassifier(random_state=42),
        'params': {
            'classifier__loss': ['hinge', 'log_loss', 'modified_huber'],
            'classifier__alpha': [0.0001, 0.001, 0.01],
            'classifier__penalty': ['l2', 'l1', 'elasticnet'],
            'classifier__learning_rate': ['constant', 'optimal', 'adaptive'],
            'classifier__eta0': [0.01, 0.1]
        }
    },
    'Logistic Regression': {
        'model': LogisticRegression(random_state=42, max_iter=1000),
        'params': {
            'classifier__C': [0.01, 0.1, 1, 10, 100],
            'classifier__penalty': ['l2'],
            'classifier__solver': ['lbfgs', 'liblinear']
        }
    },
    'KNeighbors Classifier': {
        'model': KNeighborsClassifier(),
        'params': {
            'classifier__n_neighbors': [3, 5, 10, 50],
            'classifier__leaf_size': [20, 30, 50],
            'classifier__weights': ['uniform', 'distance'],
            'classifier__p': [1, 2]  # 1=Manhattan, 2=Euclidean
        }
    },
    'Gradient Boosting Classifier': {
        'model': GradientBoostingClassifier(random_state=42),
        'params': {
            'classifier__n_estimators': [100, 200, 300],
            'classifier__learning_rate': [0.01, 0.05, 0.1],
            'classifier__max_depth': [3, 4, 5],
            'classifier__subsample': [0.8, 1.0],
            'classifier__max_features': ['sqrt', 'log2']
        }
    },
    'GaussianNB': {
        'model': GaussianNB(),
        'params': {
            'classifier__var_smoothing': [1e-9, 1e-8, 1e-7]
        }
    },
    'MLP Classifier': {
        'model': MLPClassifier(max_iter=2000, early_stopping=True, random_state=42),
        'params': {
            'classifier__hidden_layer_sizes': [(50,), (100,), (50, 50), (100, 100), (50, 50, 50)],
            'classifier__activation': ['relu', 'tanh'],
            'classifier__solver': ['adam', 'lbfgs'],
            'classifier__alpha': [0.0001, 0.001, 0.01]
        }
    },
    'support vector machine': {
        'model': SVC(probability=True, random_state=42),
        'params': {
            'classifier__C': [0.1, 1, 10],
            'classifier__kernel': ['linear', 'rbf', 'poly'],
            'classifier__gamma': ['scale', 'auto']
        }
    }
}


# Dictionary to store results
results = {}

# Loop through models
for name, mp in model_params.items():
    print(f"Tuning and evaluating: {name}")
    pipeline = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', mp['model'])
    ])

    grid = GridSearchCV(pipeline, mp['params'], cv=StratifiedKFold(n_splits=5),
                        scoring='roc_auc')

    grid.fit(X_train, y_train)

    # Best estimator after grid search
    best_model = grid.best_estimator_

    # Cross-validation scores
    cv_scores_auc = cross_val_score(best_model, X_train, y_train, cv=5, scoring='roc_auc')
    cv_scores_f1 = cross_val_score(best_model, X_train, y_train, cv=5, scoring='f1')

    results[name] = {
        'Best Parameters': json.dumps(grid.best_params_),
        'Mean AUC (Train)': np.mean(cv_scores_auc),
        'Mean F1 Score (Train)': np.mean(cv_scores_f1)
    }

    # Calculate metrics on train and test sets
    metrics = calculate_metrics(best_model, X_train, y_train, X_test, y_test)
    results[name].update(metrics)

# Create and save the result DataFrame
results_df = pd.DataFrame(results).transpose()
results_df = results_df.sort_values(by='Test AUC', ascending=False)
results_df.to_csv('model_evaluation_results_with_gridsearch.csv')

# Display result
print(results_df)

"""## Model performance"""

# Add ML classifiers here (with the best performing parameter combinations)
classifiers = [
    ('Random Forest', RandomForestClassifier(
        max_depth=None,
        min_samples_split=5,
        n_estimators=500,
        random_state=42
    )),

    ('SGD Classifier', SGDClassifier(
        alpha=0.01,
        eta0=0.01,
        learning_rate='constant',
        loss='log_loss',
        penalty='l1',
        random_state=42
    )),

    ('Logistic Regression', LogisticRegression(
        C=0.01,
        penalty='l2',
        solver='lbfgs',
        random_state=42
    )),

    ('KNeighbors Classifier', KNeighborsClassifier(
        leaf_size=20,
        n_neighbors=50,
        p=2,
        weights='distance'
    )),

    ('Gradient Boosting Classifier', GradientBoostingClassifier(
        learning_rate=0.01,
        max_depth=3,
        max_features='sqrt',
        n_estimators=200,
        subsample=1.0,
        random_state=42
    )),

    ('GaussianNB', GaussianNB(
        var_smoothing=1e-09
    )),

    ('MLP Classifier', MLPClassifier(
        activation='tanh',
        alpha=0.0001,
        hidden_layer_sizes=(50, 50, 50),
        solver='adam',
        max_iter=1000,
        random_state=42
    )),

    ('Support Vector Machine', SVC(
        C=0.1,
        gamma='scale',
        kernel='linear',
        random_state=42
    ))
]


# Function to calculate metrics
def calculate_metrics(model, X_train, y_train, X_test, y_test):
    model.fit(X_train, y_train)
    y_test_pred = model.predict(X_test)
    y_train_pred = model.predict(X_train)

    def safe_divide(a, b):
        return a / b if b != 0 else 0

    def compute_all_metrics(y_true, y_pred, prefix=""):
        auc = roc_auc_score(y_true, y_pred)
        f1 = classification_report(y_true, y_pred, output_dict=True)['1']['f1-score']
        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
        return {
            f'{prefix}AUC': auc,
            f'{prefix}F1 Score': f1,
            f'{prefix}Sensitivity': safe_divide(tp, tp + fn),
            f'{prefix}Specificity': safe_divide(tn, tn + fp),
            f'{prefix}NPV': safe_divide(tn, tn + fn),
            f'{prefix}PPV': safe_divide(tp, tp + fp)
        }

    metrics = compute_all_metrics(y_train, y_train_pred, prefix="Train ")
    metrics.update(compute_all_metrics(y_test, y_test_pred, prefix="Test "))
    return metrics, model.predict(X_test), y_test

# Bootstrapping function for CI
def bootstrap_ci(metric_func, y_true, y_pred, n_iterations=1000, alpha=0.95):
    scores = []
    for _ in range(n_iterations):
        indices = np.random.randint(0, len(y_true), len(y_true))
        if len(np.unique(y_true[indices])) < 2:
            continue
        score = metric_func(y_true[indices], y_pred[indices])
        scores.append(score)
    lower = np.percentile(scores, ((1.0 - alpha) / 2.0) * 100)
    upper = np.percentile(scores, (alpha + ((1.0 - alpha) / 2.0)) * 100)
    return f"{np.mean(scores):.3f} ({lower:.3f}-{upper:.3f})"

# Metric functions for bootstrap
metric_functions = {
    'Test AUC': roc_auc_score,
    'Test F1 Score': lambda y, p: classification_report(y, p, output_dict=True)['1']['f1-score'],
    'Test Sensitivity': lambda y, p: confusion_matrix(y, p).ravel()[3] / (confusion_matrix(y, p).ravel()[2] + confusion_matrix(y, p).ravel()[3]),
    'Test Specificity': lambda y, p: confusion_matrix(y, p).ravel()[0] / (confusion_matrix(y, p).ravel()[0] + confusion_matrix(y, p).ravel()[1]),
    'Test NPV': lambda y, p: confusion_matrix(y, p).ravel()[0] / (confusion_matrix(y, p).ravel()[0] + confusion_matrix(y, p).ravel()[2]),
    'Test PPV': lambda y, p: confusion_matrix(y, p).ravel()[3] / (confusion_matrix(y, p).ravel()[3] + confusion_matrix(y, p).ravel()[1]),
}

# Main evaluation loop
results = {}
for name, clf in classifiers:
    print(f"Evaluating: {name}")
    pipeline = Pipeline(steps=[('preprocessor', preprocessor), ('classifier', clf)])

    # Cross-validated scores
    cv_auc = cross_val_score(pipeline, X_train, y_train, cv=StratifiedKFold(n_splits=5), scoring='roc_auc')
    cv_f1 = cross_val_score(pipeline, X_train, y_train, cv=StratifiedKFold(n_splits=5), scoring='f1')

    results[name] = {
        'Mean AUC (Train)': np.mean(cv_auc),
        'Mean F1 Score (Train)': np.mean(cv_f1)
    }

    # Fit and compute metrics
    metrics, y_test_pred, y_test_true = calculate_metrics(pipeline, X_train, y_train, X_test, y_test)
    results[name].update(metrics)

    # Bootstrap CI for each test metric
    for metric, func in metric_functions.items():
        ci = bootstrap_ci(func, np.array(y_test_true), np.array(y_test_pred))
        results[name][metric + " (95% CI)"] = ci

# Convert results to DataFrame and save
results_df = pd.DataFrame(results).transpose()
results_df.to_csv("model_evaluation.csv")
print(results_df)

"""## ROC Curve Analysis"""

# Set seaborn style
sns.set(style="whitegrid", font_scale=1.2)

# Recompute AUCs based on current fitting for correct plotting order
model_results = []

for name, clf in classifiers:
    pipeline = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', clone(clf))  # prevent shared state
    ])
    pipeline.fit(X_train, y_train)

    # Get prediction scores
    if hasattr(pipeline.named_steps['classifier'], "predict_proba"):
        y_score = pipeline.predict_proba(X_test)[:, 1]
    else:
        y_score = pipeline.decision_function(X_test)

    # Compute ROC
    fpr, tpr, _ = roc_curve(y_test, y_score)
    roc_auc = auc(fpr, tpr)

    # Append all needed info
    model_results.append({
        'name': name,
        'clf': clf,
        'fpr': fpr,
        'tpr': tpr,
        'roc_auc': roc_auc,
        'auc_ci_str': results_df.loc[name, 'Test AUC (95% CI)']  # Keep CI string from table
    })

# Sort by actual ROC AUC from prediction
model_results = sorted(model_results, key=lambda x: x['roc_auc'], reverse=True)

# Define consistent color map
palette = sns.color_palette("tab10", len(model_results))
color_map = {model['name']: palette[idx] for idx, model in enumerate(model_results)}

# Plot
plt.figure(figsize=(10, 8))

for model in model_results:
    plt.plot(
        model['fpr'], model['tpr'],
        lw=2,
        color=color_map[model['name']],
        label=f"{model['name']} (AUC = {model['auc_ci_str']})"
    )

# Diagonal line
plt.plot([0, 1], [0, 1], color='gray', linestyle='--', lw=1)

# Labels and title
plt.xlabel('False Positive Rate', fontsize=13)
plt.ylabel('True Positive Rate', fontsize=13)
plt.title('ROC Curves for Predicting the Presence of CAC in All Participants', fontsize=15, weight='bold')

# Legend
plt.legend(loc='lower right', fontsize=10, frameon=True, title='Model AUCs (95% CI) on the Test Set')

# Grid and layout
plt.grid(True, linestyle='--', alpha=0.4)
plt.tight_layout()

# Save as high-resolution PDF
plt.savefig("roc_curves_CAC0_overall.pdf", format='pdf', dpi=600, bbox_inches='tight')

# Show
plt.show()

"""## Threshold Selection and Diagnostic Accuracy"""

# === Define and fit the models (SVM for overall and men; Random Forest for women) ===
svc_model = Pipeline(steps=[
    ('preprocessor', preprocessor),  # existing preprocessing pipeline
    ('classifier', SVC(
        C=0.1,
        kernel='linear',
        gamma='scale',
        random_state=42,
        probability=False  # no need since we'll use decision_function
    ))
])
svc_model.fit(X_train, y_train)

# === Get decision scores for svm and predicted probalitites for RF ===
decision_scores = svc_model.decision_function(X_test)

# === Normalize decision scores to [0, 1] for fair thresholding ===
# This step improves interpretability (similar to probabilities); not needed for Random Forest
min_score = decision_scores.min()
max_score = decision_scores.max()
y_scores = (decision_scores - min_score) / (max_score - min_score)

# === Sweep thresholds from 0 to 1 ===
thresholds = np.linspace(0, 1, 101)
results = []

for threshold in thresholds:
    y_pred = (y_scores >= threshold).astype(int)

    tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()

    sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0
    specificity = tn / (tn + fp) if (tn + fp) > 0 else 0
    ppv = precision_score(y_test, y_pred, zero_division=0)
    npv = tn / (tn + fn) if (tn + fn) > 0 else 0
    f1 = f1_score(y_test, y_pred, zero_division=0)
    youden = sensitivity + specificity - 1

    results.append({
        "Threshold": threshold,
        "Test Sensitivity": sensitivity,
        "Test Specificity": specificity,
        "Test PPV": ppv,
        "Test NPV": npv,
        "Test F1 Score": f1,
        "Youden Index": youden
    })

# === Save to CSV ===
results_df = pd.DataFrame(results)
results_df.to_csv("threshold_metrics_curve.csv", index=False)

# Optional: show top few rows
print(results_df.head())

# customizing threshold for defining rule in and rule out metrics
# === Fit model (SVM for overall and men; Random Forest for women) ===
svc_model = Pipeline(steps=[
    ('preprocessor', preprocessor),  # your existing preprocessing
    ('classifier', SVC(
        C=0.1,
        kernel='linear',
        gamma='scale',
        random_state=42,
        probability=False
    ))
])
svc_model.fit(X_train, y_train)

# === Get and normalize decision scores ===
# === This step improves interpretability (similar to probabilities); not needed for Random Forest ===
decision_scores = svc_model.decision_function(X_test)
y_scores = (decision_scores - decision_scores.min()) / (decision_scores.max() - decision_scores.min())

# === Set your threshold here ===
your_threshold = 0.81  # You can change this value
y_pred = (y_scores >= your_threshold).astype(int)

# === Define metric calculation ===
def compute_metrics(y_true, y_pred):
    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()

    sens = tp / (tp + fn) if (tp + fn) > 0 else 0
    spec = tn / (tn + fp) if (tn + fp) > 0 else 0
    ppv = tp / (tp + fp) if (tp + fp) > 0 else 0
    npv = tn / (tn + fn) if (tn + fn) > 0 else 0
    f1 = f1_score(y_true, y_pred, zero_division=0)
    youden = sens + spec - 1

    return sens, spec, ppv, npv, f1, youden

# === Bootstrap CI function ===
def bootstrap_ci(y_true, y_pred, n_iterations=1000, alpha=0.95):
    metrics_list = []

    y_true = np.array(y_true)
    y_pred = np.array(y_pred)

    for _ in range(n_iterations):
        indices = np.random.randint(0, len(y_true), len(y_true))
        y_true_boot = y_true[indices]
        y_pred_boot = y_pred[indices]

        # skip resample with only one class
        if len(np.unique(y_true_boot)) < 2:
            continue

        m = compute_metrics(y_true_boot, y_pred_boot)
        metrics_list.append(m)

    metrics_array = np.array(metrics_list)
    ci_results = {}
    metric_names = ['Sensitivity', 'Specificity', 'PPV', 'NPV', 'F1 Score', 'Youden Index']

    for i, name in enumerate(metric_names):
        mean = np.mean(metrics_array[:, i])
        lower = np.percentile(metrics_array[:, i], 2.5)
        upper = np.percentile(metrics_array[:, i], 97.5)
        ci_results[name] = f"{mean:.3f} ({lower:.3f}â€“{upper:.3f})"

    return ci_results

# === Run CI analysis and print results ===
ci_results = bootstrap_ci(y_test, y_pred)
print(f"Performance metrics at threshold = {your_threshold}:")
for metric, value in ci_results.items():
    print(f"{metric}: {value}")

"""## Feature Importance Analysis"""

# === Feature Importance Analysis: SVM on Overall Dataset and Men; RF on women ===
# Define pipeline with optimal model
svc_model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', SVC(C=0.1, kernel='linear', gamma='scale', random_state=42))
])

# Fit the model
svc_model.fit(X_train, y_train)

# === Helper: Get feature names after preprocessing ===
def get_feature_names(preprocessor):
    try:
        return preprocessor.get_feature_names_out()
    except:
        # Fallback for older versions of scikit-learn
        output_features = []
        for name, transformer, columns in preprocessor.transformers_:
            if hasattr(transformer, 'get_feature_names_out'):
                names = transformer.get_feature_names_out()
            elif hasattr(transformer, 'get_feature_names'):
                names = transformer.get_feature_names()
            else:
                names = columns
            output_features.extend([f"{name}__{col}" for col in names])
        return output_features

# Get feature names
# SVM: use model coefficients
# Random Forest: use feature_importances_ attribute
feature_names = get_feature_names(svc_model.named_steps['preprocessor'])
coefficients = svc_model.named_steps['classifier'].coef_.flatten()

# Create DataFrame of absolute coefficients
importance_df = pd.DataFrame({
    'Feature': feature_names,
    'Importance': np.abs(coefficients)
})

# Filter out zero-importance features
importance_df = importance_df[importance_df['Importance'] > 0]

# Sort by importance
importance_df = importance_df.sort_values(by='Importance', ascending=False).reset_index(drop=True)

# Print sorted feature names for reference
print("Sorted Features by Importance:")
for i, feat in enumerate(importance_df['Feature'], 1):
    print(f"{i}. {feat}")

# === Optional: Custom display names ===
custom_name_mapping = {
    'num__age': 'Age',
    'cat__sex': 'Sex',
    'cat__dm': 'Diabetes Mellitus',
    'cat__fmh_CVD': 'Family History of CVD',
    'cat__liver_fat_content_MASLD': 'MASLD Severity (Steatosis)',
    'cat__fmh_dm': 'Family History of Diabetes',
    'cat__physical_act': 'Physical Activity',
    'cat__fmh_fld': 'Family History of SLD',
    'cat__asa': 'Aspirin Use',
    'num__bun': 'Blood Urea Nitrogen',
    'num__dbp': 'Diastolic Blood Pressure',
    'num__sbp': 'Systolic Blood Pressure',
    'num__sitting_time_hour': 'Sitting Time (hours)',
    'cat__htn': 'Hypertension',
    'num__gfr': 'Glomerular Filtration Rate',
    'num__no_cmrf': 'Number of CMRFs',
    'num__hc': 'Hip Circumference',
    'cat__alcohol_cat': 'Alcohol Consumption',
    'cat__statin': 'Statin Use',
    'cat__hypothyroid': 'Hypothyroidism',
    'cat__cigarette_cat': 'Smoking Status',
    'cat__hlp': 'Hyperlipidemia',
    'num__bmi': 'Body Mass Index',
    'num__wc': 'Waist Circumference',
    'num__ef': 'Ejection Fraction'
}

# Map display names
importance_df['Display Feature'] = importance_df['Feature'].map(custom_name_mapping).fillna(importance_df['Feature'])

# === Plotting ===
plt.figure(figsize=(5, 8))
sns.barplot(x='Importance', y='Display Feature', data=importance_df, color='black')
plt.title('SVM (All Participants)')
plt.grid(True, linestyle='', alpha=0.4)
plt.tight_layout()

# Save high-resolution plot
plt.savefig("feature_importance.pdf", format='pdf', dpi=1200, bbox_inches='tight')
plt.show()